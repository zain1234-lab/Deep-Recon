# Function Tables for Provided Files

## File: whois_lookup.py

| Function Name | Signature | Parameters | Return Type | Extended Description |
|---------------|-----------|------------|-------------|-------------|
| `sanitize_domain` | `sanitize_domain(domain: str) -> str` | `domain: str` - Domain name to validate | `str` | This standalone function serves as a convenience wrapper for domain sanitization, leveraging the `EnhancedWhoisLookup` class’s `sanitize_domain` method. It takes a raw domain input (e.g., "http://www.example.com/") and processes it to ensure a clean, standardized format (e.g., "example.com"). The function removes protocols (http:// or https://), "www." prefixes, and trailing slashes, converting the domain to lowercase. It uses `tldextract` for robust parsing or falls back to regex validation to confirm the domain’s format. If the domain is invalid (e.g., empty, malformed, or lacking a valid TLD), it raises a `ValueError`. This function is designed for backward compatibility, allowing external scripts to sanitize domains without instantiating the full `EnhancedWhoisLookup` class. It’s particularly useful in scenarios where quick domain validation is needed before further processing, such as in CLI tools or scripts interfacing with WHOIS services. |
| `get_whois` | `get_whois(domain: str, proxies: Optional[Dict[str, str]] = None, cache_file: Optional[str] = None) -> Dict[str, Any]` | `domain: str` - Target domain<br>`proxies: Optional[Dict[str, str]]` - Proxy configuration<br>`cache_file: Optional[str]` - Cache file path (deprecated) | `Dict[str, Any]` | This function provides a high-level interface for performing WHOIS lookups, maintaining backward compatibility with older scripts. It creates an instance of `EnhancedWhoisLookup` and calls its `lookup` method to retrieve WHOIS data for the specified domain. The function supports optional proxy configurations (e.g., for TOR routing) and a deprecated `cache_file` parameter, which it converts to a cache directory for compatibility. The returned dictionary contains comprehensive WHOIS details, such as registrar, creation/expiration dates, name servers, and contact information, extracted from the `WhoisResult` object. If the lookup fails, it logs the error and raises a `RuntimeError` with a descriptive message. This function is ideal for scripts needing a simple, robust WHOIS query mechanism with minimal setup, commonly used in reconnaissance workflows to gather domain registration metadata. |
| `_install_dependencies` | `_install_dependencies(self)` | None | None | This private method within `EnhancedWhoisLookup` attempts to automatically install missing Python dependencies (`python-whois`, `whois`, `requests`, `dnspython`, `tldextract`) using `pip` when the class is initialized and detects missing packages. It iterates through a predefined list of packages, running `subprocess.check_call` to execute `pip install` commands silently (suppressing output). Success or failure is logged for each package, with errors indicating potential installation issues (e.g., network errors, permission issues). This method enhances user experience by reducing manual setup requirements, particularly for novice users or automated deployment scenarios. However, it assumes `pip` is available and has sufficient permissions, which may not always hold true in restricted environments. It’s a proactive feature to ensure the tool remains functional even if dependencies are not pre-installed. |
| `_create_session` | `_create_session(self) -> requests.Session` | None | `requests.Session` | This private method initializes a `requests.Session` object configured for robust HTTP communication within the `EnhancedWhoisLookup` class. It sets up a retry strategy using `urllib3.util.retry.Retry` to handle transient HTTP errors (429, 500, 502, 503, 504) with exponential backoff. The session is mounted with an `HTTPAdapter` to apply retries for both HTTP and HTTPS requests. To evade potential blocking by WHOIS servers, it randomly selects a user agent from a predefined list (mimicking browsers like Chrome or Firefox) and sets headers for accept, language, encoding, and connection. This configuration ensures reliable, resilient HTTP requests for WHOIS-related queries, particularly when fallback methods involve web-based WHOIS services. The method is critical for maintaining stable communication in environments with unreliable networks or strict server policies. |
| `sanitize_domain` (method) | `sanitize_domain(self, domain: str) -> str` | `domain: str` - Domain name to validate | `str` | This method, part of the `EnhancedWhoisLookup` class, provides enhanced domain sanitization and validation. It processes raw domain inputs by stripping protocols (http://, https://), "www." prefixes, and trailing slashes, and converts the domain to lowercase. The method prioritizes `tldextract` for accurate domain parsing (separating domain and suffix, e.g., "example.com" into "example" and "com"), falling back to a regex pattern (`^[a-z0-9][a-z0-9\-]{0,61}[a-z0-9](?:\.[a-z]{2,})+$`) if `tldextract` fails. Invalid domains (e.g., empty strings, missing TLDs, or malformed formats) trigger a `ValueError`. This method is integral to the WHOIS lookup process, ensuring only valid domains are queried, preventing errors in downstream operations like socket queries or API calls. Its robust parsing makes it suitable for handling diverse user inputs in reconnaissance tools. |
| `_rate_limit` | `_rate_limit(self)` | None | None | This private method enforces rate limiting to prevent WHOIS servers from blocking requests due to excessive querying. It tracks the time of the last request (`self.last_request_time`) and calculates the elapsed time since then. If the elapsed time is less than the configured `rate_limit_delay` (default 1.0 seconds), it pauses execution using `time.sleep` to meet the delay requirement. The method updates the last request timestamp after enforcing the delay. This mechanism is crucial for compliance with WHOIS server policies, which often impose strict rate limits to prevent abuse. By spacing out requests, it reduces the risk of IP bans or 429 (Too Many Requests) errors, ensuring reliable operation during batch or repeated lookups. |
| `_get_cache_path` | `_get_cache_path(self, domain: str, cache_dir: Optional[str] = None) -> Path` | `domain: str` - Domain name<br>`cache_dir: Optional[str]` - Cache directory path | `Path` | This private method generates a file path for caching WHOIS data. It uses the domain name and an optional cache directory (defaulting to `~/.whois_cache`). To avoid filesystem issues with special characters in domain names, it creates a filename by combining the domain with its MD5 hash (e.g., `example.com_<hash>.json`). The method ensures the cache directory exists using `Path.mkdir` with `parents=True`. This approach provides a reliable, unique cache file for each domain, facilitating efficient storage and retrieval of WHOIS results. It’s essential for optimizing performance in repeated lookups, reducing network requests, and maintaining data persistence across tool executions. |
| `_is_cache_valid` | `_is_cache_valid(self, cache_file: Path) -> bool` | `cache_file: Path` - Path to cache file | `bool` | This private method checks whether a cached WHOIS result is still valid. It verifies if the cache file exists and calculates its age by comparing the file’s last modification time (`stat.st_mtime`) to the current time. The cache is considered valid if its age is less than the configured `cache_ttl_hours` (default 24 hours). If the file doesn’t exist or is too old, or if an error occurs (e.g., permission issues), it returns `False`. This method supports efficient caching by ensuring only fresh data is used, preventing stale WHOIS information from affecting results. It’s a key component of the tool’s performance optimization strategy. |
| `_load_from_cache` | `_load_from_cache(self, domain: str, cache_dir: Optional[str] = None) -> Optional[WhoisResult]` | `domain: str` - Domain name<br>`cache_dir: Optional[str]` - Cache directory | `Optional[WhoisResult]` | This private method retrieves cached WHOIS data for a domain. It generates the cache file path using `_get_cache_path` and checks its validity with `_is_cache_valid`. If valid, it reads the JSON file, deserializes it into a dictionary, and constructs a `WhoisResult` object. If the cache is invalid, missing, or fails to load (e.g., due to JSON parsing errors or file access issues), it logs a warning and returns `None`. This method enhances performance by avoiding redundant WHOIS queries for recently accessed domains, making it ideal for batch processing or repeated scans. It also logs debug messages for successful cache loads, aiding in troubleshooting. |
| `_save_to_cache` | `_save_to_cache(self, result: WhoisResult, cache_dir: Optional[str] = None)` | `result: WhoisResult` - WHOIS result to cache<br>`cache_dir: Optional[str]` - Cache directory | None | This private method saves a `WhoisResult` object to a cache file in JSON format. It generates the cache file path using `_get_cache_path`, converts the result to a dictionary with `to_dict`, and writes it to the file with proper encoding (`utf-8`). If the write operation fails (e.g., due to permission errors or disk issues), it logs a warning but does not raise an exception, ensuring the tool continues functioning. The method logs debug messages on success, providing traceability. This caching mechanism reduces network overhead and improves efficiency, especially in scenarios involving frequent WHOIS lookups for the same domains. |
| `_whois_socket_query` | `_whois_socket_query(self, domain: str, server: str) -> Optional[str]` | `domain: str` - Domain name<br>`server: str` - WHOIS server | `Optional[str]` | This private method performs a raw WHOIS query using a TCP socket connection to the specified WHOIS server (port 43). It establishes a connection, sends the domain query followed by `\r\n`, and receives the response in chunks (up to 4096 bytes) until complete. The response is decoded as UTF-8 (ignoring errors) and returned as a string. If the connection fails (e.g., due to network issues, timeouts, or server unavailability), it logs a warning and returns `None`. This method provides a low-level, direct approach to WHOIS queries, serving as a fallback when library-based methods (`python-whois`, `whois`) fail. It’s particularly useful for querying WHOIS servers not supported by standard libraries or in restricted environments. |
| `_get_tld_whois_server` | `_get_tld_whois_server(self, domain: str) -> str` | `domain: str` - Domain name | `str` | This private method determines the appropriate WHOIS server for a domain based on its top-level domain (TLD). It extracts the TLD (e.g., "com" from "example.com") and looks it up in a predefined dictionary mapping TLDs to WHOIS servers (e.g., "com" to "whois.verisign-grs.com"). If the TLD is not found, it defaults to "whois.iana.org". The method handles exceptions gracefully, ensuring a fallback server is always returned. This functionality is critical for socket-based WHOIS queries, as it ensures the correct server is targeted, improving query success rates and accuracy. |
| `_parse_raw_whois` | `_parse_raw_whois(self, raw_data: str, domain: str) -> Dict[str, Any]` | `raw_data: str` - Raw WHOIS response<br>`domain: str` - Domain name | `Dict[str, Any]` | This private method parses raw WHOIS response text into a structured dictionary. It splits the response into lines, skipping comments (lines starting with `%` or `#`) and empty lines. Using regex patterns, it extracts fields like registrar, creation/expiration dates, name servers, emails, and DNSSEC status. Emails are collected using a separate regex, while lists (e.g., name servers, status) are deduplicated. The method initializes a dictionary with default `None` or empty list values, populating only the first match for single-value fields to avoid overwrites. This parsing is essential for socket-based WHOIS queries, converting unstructured text into usable data for `WhoisResult` objects. Its regex-based approach ensures flexibility across different WHOIS server response formats. |
| `_method_python_whois` | `_method_python_whois(self, domain: str, proxies: Optional[Dict] = None) -> Optional[WhoisResult]` | `domain: str` - Domain name<br>`proxies: Optional[Dict]` - Proxy configuration | `Optional[WhoisResult]` | This private method performs a WHOIS lookup using the `python-whois` library. It measures the response time, queries the domain, and constructs a `WhoisResult` object from the library’s output. It handles cases where fields like registrar or dates are lists (taking the first element) or missing (using defaults like "N/A"). If the query fails (e.g., due to network issues or library errors), it logs a warning and returns `None`. This method is one of the three fallback approaches in the `lookup` method, prioritized for its simplicity and direct access to WHOIS data. It’s suitable for standard domains but may fail for less common TLDs, necessitating other methods. |
| `_method_whois_library` | `_method_whois_library(self, domain: str, proxies: Optional[Dict] = None) -> Optional[WhoisResult]` | `domain: str` - Domain name<br>`proxies: Optional[Dict]` - Proxy configuration | `Optional[WhoisResult]` | This private method uses the `whois` library to perform a WHOIS lookup. It supports proxy configurations, measures response time, and processes the library’s output into a `WhoisResult` object. A helper function `safe_get` handles both single values and lists, ensuring consistent data extraction (e.g., taking the first element of a list or defaulting to "N/A"). The method captures raw response text if available and logs failures (e.g., network errors, library issues), returning `None` on error. As a fallback in the `lookup` method, it offers robust parsing for a wide range of TLDs, complementing `python-whois` and socket-based queries. |
| `_method_socket_whois` | `_method_socket_whois(self, domain: str) -> Optional[WhoisResult]` | `domain: str` - Domain name | `Optional[WhoisResult]` | This private method conducts a WHOIS lookup using a raw socket query via `_whois_socket_query`. It selects the WHOIS server with `_get_tld_whois_server`, measures response time, and parses the raw response with `_parse_raw_whois`. The resulting data is used to create a `WhoisResult` object, including the raw response text and server details. If the query or parsing fails, it logs a warning and returns `None`. This method is the final fallback in the `lookup` method, offering a low-level approach that bypasses library dependencies, making it resilient in environments where libraries fail or are unavailable. |
| `lookup` | `lookup(self, domain: str, proxies: Optional[Dict[str, str]] = None, cache_dir: Optional[str] = None, use_cache: bool = True, methods: Optional[List[str]] = None) -> WhoisResult` | `domain: str` - Target domain<br>`proxies: Optional[Dict[str, str]]` - Proxy configuration<br>`cache_dir: Optional[str]` - Cache directory<br>`use_cache: bool` - Use caching<br>`methods: Optional[List[str]]` - Lookup methods to try | `WhoisResult` | This core method orchestrates an enhanced WHOIS lookup with multiple fallback strategies. It sanitizes the domain, checks the cache (if enabled) using `_load_from_cache`, and applies rate limiting with `_rate_limit`. It then attempts lookups using specified methods (`python-whois`, `whois-library`, `socket`) in order, defaulting to all three if none are specified. Each method is tried until a valid `WhoisResult` is obtained, with proxies applied for library-based methods. Successful results are cached via `_save_to_cache`. If all methods fail, it raises a `RuntimeError` with the last error details. This method’s robust, multi-method approach ensures high reliability, making it the primary entry point for WHOIS queries in the tool. |
| `lookup_async` | `lookup_async(self, domain: str, proxies: Optional[Dict[str, str]] = None, cache_dir: Optional[str] = None, use_cache: bool = True) -> WhoisResult` | `domain: str` - Target domain<br>`proxies: Optional[Dict[str, str]]` - Proxy configuration<br>`cache_dir: Optional[str]` - Cache directory<br>`use_cache: bool` - Use caching | `WhoisResult` | This method provides an asynchronous interface for WHOIS lookups by wrapping the synchronous `lookup` method. It uses a `ThreadPoolExecutor` with a single worker to run the lookup in a separate thread, allowing integration with async/await workflows. The result is awaited and returned as a `WhoisResult`. This method is useful in asynchronous applications or frameworks (e.g., FastAPI, asyncio-based scripts) where blocking calls need to be avoided. Its implementation ensures compatibility with the synchronous lookup’s features, including caching and proxy support, while enabling non-blocking operation. |
| `batch_lookup` | `batch_lookup(self, domains: List[str], proxies: Optional[Dict[str, str]] = None, cache_dir: Optional[str] = None, use_cache: bool = True, max_workers: int = 5) -> Dict[str, Union[WhoisResult, Exception]]` | `domains: List[str]` - List of domains<br>`proxies: Optional[Dict[str, str]]` - Proxy configuration<br>`cache_dir: Optional[str]` - Cache directory<br>`use_cache: bool` - Use caching<br>`max_workers: int` - Max concurrent workers | `Dict[str, Union[WhoisResult, Exception]]` | This method performs concurrent WHOIS lookups for a list of domains using a `ThreadPoolExecutor`. It submits each domain to the `lookup` method, limiting concurrency to `max_workers` (default 5) to avoid overwhelming servers or local resources. Results are collected as a dictionary mapping each domain to either a `WhoisResult` or an exception if the lookup fails. The method logs progress and errors, supporting proxies and caching. This functionality is ideal for bulk reconnaissance tasks, such as analyzing multiple domains in a single operation, with built-in error handling to ensure partial failures don’t halt the process. |
| `get_dns_info` | `get_dns_info(self, domain: str) -> Dict[str, Any]` | `domain: str` - Domain name | `Dict[str, Any]` | This method retrieves DNS records for a domain using the `dnspython` library. It queries for A, AAAA, MX, NS, TXT, and CNAME records, storing each type’s results in a dictionary (e.g., `A_records: ["1.2.3.4"]`). If a query fails (e.g., due to NXDOMAIN or no answers), it skips that record type. Errors are logged but don’t halt execution, ensuring a partial result is returned. This method complements WHOIS lookups by providing additional network context, such as IP addresses, mail servers, or DNS security configurations, which are valuable for reconnaissance and vulnerability assessment. |

## File: utils.py

| Function Name | Signature | Parameters | Return Type | Extended Description |
|---------------|-----------|------------|-------------|-------------|
| `setup_logging` | `setup_logging(level: str) -> logging.Logger` | `level: str` - Logging level (‘DEBUG’, ‘INFO’, ‘WARNING’) | `logging.Logger` | This function configures a logger for the reconnaissance tool, named `recon_tool`. It sets the logging level based on the input (defaulting to `INFO` if invalid), using Python’s `logging` module. Two handlers are added: a console handler for real-time output and a file handler saving logs to `reports/recon.log`. Both use a consistent format (`%(asctime)s - %(levelname)s - %(message)s`) for readability. The method creates the `reports` directory if needed, ensuring logs are saved even in new environments. This logger is used across all modules for consistent debugging, monitoring, and auditing, making it easier to trace issues or review scan activities. Its flexibility allows users to adjust verbosity via command-line arguments (e.g., `--verbose` or `--quiet`). |
| `check_tor` | `check_tor() -> bool` | None | `bool` | This function checks if a TOR service is running on `localhost:9050`, the default TOR proxy port. It creates a TCP socket, sets a 2-second timeout, and attempts to connect to the TOR address. A successful connection (return code 0) indicates TOR is available, returning `True`; otherwise, it returns `False`. This check is critical for enabling stealth mode in the reconnaissance tool, as TOR routing anonymizes requests. The method handles socket errors gracefully, ensuring the tool can proceed without crashing if TOR is unavailable. It’s used in `get_proxies` and `recon_tool_main.py` to determine whether stealth mode with TOR is feasible. |
| `get_proxies` | `get_proxies() -> Optional[Dict[str, str]]` | None | `Optional[Dict[str, str]]` | This function returns a proxy configuration for TOR if the service is available, as determined by `check_tor`. If TOR is running, it returns a dictionary specifying `socks5h://127.0.0.1:9050` for both HTTP and HTTPS protocols, enabling proxy routing for requests. If TOR is unavailable, it returns `None`. This configuration is used in modules like `whois_lookup`, `subdomains`, and `vuln_scan` to anonymize network requests in stealth mode, reducing the risk of detection or IP-based blocking. The function simplifies proxy setup, ensuring consistent TOR integration across the tool’s network operations. |
| `stealth_delay` | `stealth_delay() -> None` | None | None | This function introduces a randomized delay between 0.5 and 3 seconds using `random.uniform` and `time.sleep`. It’s designed for stealth mode to mimic human-like behavior, reducing the likelihood of detection by rate-limiting systems or intrusion detection mechanisms during scans. The variable delay helps avoid predictable request patterns, which could trigger server-side protections. This method is called after module executions in `recon_tool_main.py` when stealth mode is enabled, enhancing the tool’s evasion capabilities during active reconnaissance tasks like port scanning or endpoint enumeration. |
| `generate_report` | `generate_report(data: Dict, filename: str, format_type: str) -> None` | `data: Dict` - Scan results<br>`filename: str` - Output file path<br>`format_type: str` - Report format (‘txt’ or ‘html’) | None | This function generates a report from reconnaissance results in either text or HTML format. It sanitizes the filename using `Path.resolve` to prevent path traversal, creates parent directories, and writes a structured report. For text reports, it includes sections for target, timestamp, scan mode, module results, and risk analysis in a plain format. For HTML reports, it uses basic HTML markup with `<pre>` tags to display JSON-formatted data, ensuring readability. Errors during file writing (e.g., permission issues) are logged but don’t raise exceptions. This function, used in `recon_tool_main.py`, provides a simple reporting mechanism for users needing quick, human-readable outputs, though it’s less feature-rich than `report_generator.py`’s advanced reporting. |

## File: vuln_scan.py

| Function Name | Signature | Parameters | Return Type | Extended Description |
|---------------|-----------|------------|-------------|-------------|
| `create_session` | `create_session() -> requests.Session` | None | `requests.Session` | This function initializes a `requests.Session` for HTTP requests in vulnerability scanning. It configures retries using `urllib3.util.retry.Retry` for handling transient errors (429, 500, 502, 503, 504) with exponential backoff. The session is mounted with an `HTTPAdapter` for both HTTP and HTTPS, and SSL verification is enforced using `certifi.where()` to ensure secure connections. This setup ensures reliable, resilient HTTP communication, critical for probing web vulnerabilities across multiple requests. The session is reused across probes in `vuln_scan` and `probe_vulnerabilities`, improving performance and maintaining consistent configurations (e.g., timeouts, retries). It’s a foundational component for the module’s network operations, balancing security and robustness. |
| `sanitize_target` | `sanitize_target(target: str) -> str` | `target: str` - IP or domain to validate | `str` | This function validates and sanitizes a target, which can be an IP address or domain. It checks if the input is a non-empty string, strips whitespace, and converts it to lowercase. Using regex, it validates IP addresses (e.g., `192.168.1.1`) with the pattern `^(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)$` and domains (e.g., `example.com`) with `^[a-z0-9][a-z0-9-]{0,61}[a-z0-9](?:\.[a-z]{2,})+$`. Invalid inputs trigger a `ValueError` with a logged error. This sanitization ensures only valid targets are scanned, preventing errors in HTTP requests or DNS resolutions. It’s used in `vuln_scan` to preprocess user inputs, enhancing reliability. |
| `sanitize_port` | `sanitize_port(port: int) -> int` | `port: int` - Port number to validate | `int` | This function validates a port number, ensuring it’s an integer between 1 and 65535 (the valid range for TCP/UDP ports). It checks the type and range, raising a `ValueError` with a logged error for invalid inputs (e.g., non-integers, negative numbers, or values >65535). The validated port is returned unchanged. This function is used in `vuln_scan` to process port lists, ensuring only valid ports are probed. Its strict validation prevents runtime errors in network operations, such as attempting to connect to invalid ports, and is essential for maintaining scan integrity. |
| `probe_vulnerabilities` | `probe_vulnerabilities(target: str, port: int, path: str, vuln_type: str, payload: str, stealth: bool, proxies: Optional[Dict[str, str]], session: requests.Session) -> Optional[Dict[str, Any]]` | `target: str` - Target IP/domain<br>`port: int` - Port to probe<br>`path: str` - Path to test<br>`vuln_type: str` - Vulnerability type<br>`payload: str` - Test payload<br>`stealth: bool` - Stealth mode<br>`proxies: Optional[Dict[str, str]]` -